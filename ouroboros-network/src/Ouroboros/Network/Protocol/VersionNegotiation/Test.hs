{-# LANGUAGE GADTs               #-}
{-# LANGUAGE DeriveGeneric       #-}
{-# LANGUAGE FlexibleInstances   #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Ouroboros.Network.Protocol.VersionNegotiation.Test where

import           Control.Monad.ST (runST)
import           Data.Typeable (Typeable, cast)
import           Data.List (nub)
import           Data.Maybe (isJust)
import qualified Data.Map as Map
import           GHC.Generics

import           Control.Monad.IOSim (runSimOrThrow)

import           Network.TypedProtocol.Codec
import           Network.TypedProtocol.Proofs

import           Ouroboros.Network.Protocol.VersionNegotiation.Type
import           Ouroboros.Network.Protocol.VersionNegotiation.Codec
import           Ouroboros.Network.Server.Version

import qualified Codec.CBOR.Encoding as CBOR
import qualified Codec.CBOR.Decoding as CBOR
import qualified Codec.CBOR.Term as CBOR
import           Codec.Serialise (Serialise)
import qualified Codec.Serialise     as CBOR

import           Test.QuickCheck
import           Test.Tasty (TestTree, testGroup)
import           Test.Tasty.QuickCheck (testProperty)

tests :: TestTree
tests =
  testGroup "Ouroboros.Network.Protocol.VersionNegotiation"
  [ testProperty "connect"             prop_connect
  , testProperty "codec"               prop_codec_VersionNegotiation
  , testGroup "Generators"
    [ testProperty "ArbitraryVersions" $
        checkCoverage prop_arbitrary_ArbitraryVersions
    , testProperty "arbitrary ArbitraryValidVersions"
        prop_arbitrary_ArbitraryValidVersions
    , testProperty "shrink ArbitraryValidVersions"
        prop_shrink_ArbitraryValidVersions
    ]
  ]

--
-- Test Versions
--
-- Notes: Associated data are choosen in such a way that a decoder will fail
-- interpreting one of them as the other.  This is done on purpose for testing
-- missencoded data (protocol version & associated version data mismatch)
--

-- |
-- Testing version number
--
data VersionNumber
  = Version_0
  | Version_1
  | Version_2
  deriving (Eq, Ord, Enum, Bounded, Show)

instance Arbitrary VersionNumber where
  arbitrary = oneof (map return [minBound .. maxBound])

instance Serialise VersionNumber where
  encode Version_0 = CBOR.encodeWord 0
  encode Version_1 = CBOR.encodeWord 1
  encode Version_2 = CBOR.encodeWord 2

  decode = do
    x <- CBOR.decodeWord
    case x of
      0 -> return Version_0
      1 -> return Version_1
      2 -> return Version_2
      _ -> fail "decode VersionNumber: wrong tag"

-- |
-- Data Associated with @'Version_0'@
--
data Data_0 = C0 | C1 | C2
  deriving (Eq, Show, Typeable, Generic)

instance SerialiseTerm Data_0 where
  -- We are using @CBOR.TInt@ instead of @CBOR.TInteger@, since for small
  -- integers generated by QuickCheck they will be encoded as @TkInt@ and then
  -- are decodec back to @CBOR.TInt@ rather than @COBR.TInteger@.  The same for
  -- other @SerialiseTerm@ instances in this module.
  encodeTerm C0 = CBOR.TInt 0
  encodeTerm C1 = CBOR.TInt 1
  encodeTerm C2 = CBOR.TInt 2

  decodeTerm (CBOR.TInt 0) = Just C0
  decodeTerm (CBOR.TInt 1) = Just C1
  decodeTerm (CBOR.TInt 2) = Just C2
  decodeTerm _             = Nothing

instance Arbitrary Data_0 where
  arbitrary = oneof [return C0, return C1, return C2]
  shrink C2 = [C1, C0]
  shrink C1 = [C0]
  shrink C0 = []

instance CoArbitrary Data_0 where

-- |
-- Data associated with @'Version_1'@
--
data Data_1 = Data_1 Bool
  deriving (Eq, Show, Typeable, Generic)

instance SerialiseTerm Data_1 where
  encodeTerm (Data_1 b) = CBOR.TBool b

  decodeTerm (CBOR.TBool b) = Just (Data_1 b)
  decodeTerm _              = Nothing

instance Arbitrary Data_1 where
  arbitrary = Data_1 <$> arbitrary
  shrink (Data_1 n) = map Data_1 (shrink n)

instance CoArbitrary Data_1

-- |
-- Data associated with @'Version_2'@
--
data Data_2 = Data_2 Word Word
  deriving (Eq, Show, Typeable, Generic)

instance SerialiseTerm Data_2 where
  encodeTerm (Data_2 n m) = CBOR.TList [CBOR.TInt (fromIntegral n), CBOR.TInt (fromIntegral m)]
  decodeTerm (CBOR.TList (CBOR.TInt n : CBOR.TInt m : _)) = Just (Data_2 (fromIntegral n) (fromIntegral m))
  decodeTerm _ = Nothing

instance Arbitrary Data_2 where
  arbitrary = Data_2 <$> arbitrary <*> arbitrary
  shrink (Data_2 n m) =
    [ Data_2 n m'
    | m' <- shrink m
    ]
    ++
    [ Data_2 n' m
    | n' <- shrink n
    ]

instance CoArbitrary Data_2 where

data DictVersion vData where
     DictVersion :: ( Typeable vData
                    , Eq vData
                    , SerialiseTerm vData
                    , Show vData
                    )
                 => DictVersion vData

--
-- ProtocolVersion generators
--

-- |
-- Generate a valid @'ProtocolVersion' 'VersionNumber' r@
--
genValidVersion
  :: VersionNumber
  -> Gen (Sigma (Version DictVersion Bool))
genValidVersion Version_0 = do
  (d0 :: Data_0) <- arbitrary
  return $ Sigma d0 (Version (Application (==)) DictVersion)
genValidVersion Version_1 = do
  (d1 :: Data_1) <- arbitrary
  return $ Sigma d1 (Version (Application (==)) DictVersion)
genValidVersion Version_2 = do
  (d2 :: Data_2) <- arbitrary
  return $ Sigma d2 (Version (Application (==)) DictVersion)


-- |
-- Generate an invalid @'ProtocolVersion' 'VersionNumber' r@.
--
genInvalidVersion
  :: VersionNumber
  -> Gen (Sigma (Version DictVersion Bool))
genInvalidVersion Version_0 = arbitrary >>= \b ->
  if b
    then do
      (d1 :: Data_1) <- arbitrary
      return $ Sigma d1 (Version (Application (==)) DictVersion)
    else do
      (d2 :: Data_2) <- arbitrary
      return $ Sigma d2 (Version (Application (==)) DictVersion)
genInvalidVersion Version_1 = arbitrary >>= \b ->
  if b
    then do
      (d0 :: Data_0) <- arbitrary
      return $ Sigma d0 (Version (Application (==)) DictVersion)
    else do
      (d2 :: Data_2) <- arbitrary
      return $ Sigma d2 (Version (Application (==)) DictVersion)
genInvalidVersion Version_2 = arbitrary >>= \b ->
  if b
    then do
      (d0 :: Data_0) <- arbitrary
      return $ Sigma d0 (Version (Application (==)) DictVersion)
    else do
      (d1 :: Data_1) <- arbitrary
      return $ Sigma d1 (Version (Application (==)) DictVersion)

-- |
-- Generate valid @Versions@.
--
genValidVersions :: Gen (Versions VersionNumber DictVersion Bool)
genValidVersions = do
  vns <- nub <$> resize 3 (listOf1 (arbitrary :: Gen VersionNumber))
  vs <- traverse genValidVersion vns
  return $ Versions $ Map.fromList $ zip vns vs

-- |
-- Generate possible invalid @Versions@.
--
genVersions :: Gen (Versions VersionNumber DictVersion Bool)
genVersions = do
  vns <- nub <$> resize 3 (listOf1 (arbitrary :: Gen VersionNumber))
  vs <- traverse (\v -> oneof [genValidVersion v, genInvalidVersion v]) vns
  return $ Versions $ Map.fromList $ zip vns vs

newtype ArbitraryValidVersions = ArbitraryValidVersions {
      runArbitraryValidVersions :: Versions VersionNumber DictVersion Bool
    }

instance Show ArbitraryValidVersions where
    show (ArbitraryValidVersions (Versions vs)) = show $ map (\(vn, Sigma vData (Version _ DictVersion)) -> (vn, show vData)) $ Map.toList vs

instance Arbitrary ArbitraryValidVersions where
    arbitrary = ArbitraryValidVersions <$> genValidVersions
    shrink (ArbitraryValidVersions (Versions vs)) =
      [ ArbitraryValidVersions (Versions $ Map.fromList vs')
      | vs' <- shrinkList (const []) (Map.toList vs)
      ]

prop_arbitrary_ArbitraryValidVersions
  :: ArbitraryValidVersions
  -> Bool
prop_arbitrary_ArbitraryValidVersions (ArbitraryValidVersions vs) = Map.foldlWithKey' (\r vn s -> r && validVersion vn s) True (getVersions vs)

prop_shrink_ArbitraryValidVersions
  :: ArbitraryValidVersions
  -> Bool
prop_shrink_ArbitraryValidVersions a = all id
  [ Map.foldlWithKey' (\r vn s -> r && validVersion vn s) True (getVersions vs')
  | ArbitraryValidVersions vs' <- shrink a
  ]

-- |
-- Generators for pairs of arbitrary list of versions.
--
data ArbitraryVersions =
  ArbitraryVersions
    (Versions VersionNumber DictVersion Bool)
    (Versions VersionNumber DictVersion Bool)

instance Show ArbitraryVersions where
    show (ArbitraryVersions (Versions vs) (Versions vs')) = "ArbitraryVersions " ++ fn vs ++ " " ++ fn vs'
         where
           fn x = show $ map (\(vn, Sigma vData (Version _ DictVersion)) -> (vn, show vData)) $ Map.toList x

instance Arbitrary ArbitraryVersions where
    arbitrary = frequency
      [ (1, (\v -> ArbitraryVersions v v) <$> genVersions)
      , (2, ArbitraryVersions <$> genVersions <*> genVersions)
      ]
    shrink (ArbitraryVersions (Versions vs) (Versions vs')) = 
      [ ArbitraryVersions (Versions $ Map.fromList vs'') (Versions vs')
      | vs'' <- shrinkList (const []) (Map.toList vs)
      ] ++
      [ ArbitraryVersions (Versions vs) (Versions $ Map.fromList vs'')
      | vs'' <- shrinkList (const []) (Map.toList vs')
      ]


-- |
-- Check if a @'ProtocolVersion' 'VersionNumber' r@ is valid.
--
validVersion :: VersionNumber -> Sigma (Version DictVersion Bool) -> Bool
validVersion Version_0 (Sigma d (Version _ DictVersion)) = isJust (cast d :: Maybe Data_0)
validVersion Version_1 (Sigma d (Version _ DictVersion)) = isJust (cast d :: Maybe Data_1)
validVersion Version_2 (Sigma d (Version _ DictVersion)) = isJust (cast d :: Maybe Data_2)


prop_arbitrary_ArbitraryVersions :: ArbitraryVersions -> Property
prop_arbitrary_ArbitraryVersions (ArbitraryVersions (Versions vs) (Versions vs')) =
    -- in 80% of cases the intersection is non-empty
    cover 80 intersect "non-empty intersection" $

    -- in 10% of cases the intersection is empty
    cover 10 (not intersect) "empty intersection" $

    -- in 25% of cases the common max version is valid
    cover 25 (case Map.lookupMax intersection of
               Nothing -> False
               Just (vn, s)  -> validVersion vn s)
               "valid common max version" $

    -- in 40% of cases all the versions in @vs'@ are either not in @vs@ or are
    -- not valid
    cover 40
      (Map.foldlWithKey' (\r vn s -> r && (not (vn `elem` knownVersionNumbers) || not (validVersion vn s))) True vs)
      "all versions are either unknown or not valid" $

    property True
  where
    intersection = vs `Map.intersection` vs' 
    intersect    = not (Map.null intersection)

    knownVersionNumbers = Map.keys vs'

-- | Run a version negotiation, but without going via a channel.
--
prop_connect :: ArbitraryVersions -> Bool
prop_connect (ArbitraryVersions clientVersions serverVersions) =
  let (serverRes, clientRes) = pureVersionNegotiation
        (\DictVersion -> Dict)
        (\DictVersion -> (==))
        serverVersions
        clientVersions
  in case runSimOrThrow
           (connect
              (versionNegotiationClientPeer (\DictVersion -> encodeTerm) (\DictVersion -> decodeTerm) clientVersions)
              (versionNegotiationServerPeer (\DictVersion -> encodeTerm) (\DictVersion -> decodeTerm) (\DictVersion -> (==)) serverVersions)) of
      (clientRes', serverRes', TerminalStates TokDone TokDone) ->
           maybe False id clientRes == either (const False) id clientRes'
        &&
           maybe False id serverRes == either (const False) id serverRes'


--
-- Codec tests
--

instance Eq (AnyMessage (VersionNegotiationProtocol VersionNumber CBOR.Term)) where
  AnyMessage (MsgProposeVersions vs)          == AnyMessage (MsgProposeVersions vs')  = vs == vs'
  AnyMessage (MsgAcceptVersion vNumber vBlob) == AnyMessage (MsgAcceptVersion vNumber' vBlob')
                                                                                      = vNumber == vNumber' && vBlob == vBlob'
  AnyMessage MsgRefuse                        == AnyMessage MsgRefuse                 = True
  AnyMessage MsgUnknownVersion                == AnyMessage MsgUnknownVersion         = True
  _                                           == _                                    = False

instance Show (AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)) where
  show (AnyMessageAndAgency _ msg) = show msg

instance Arbitrary (AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)) where
  arbitrary = oneof
    [ AnyMessageAndAgency (ClientAgency TokPropose) . MsgProposeVersions . fmap (\(Sigma vData (Version _ DictVersion)) -> encodeTerm vData) . getVersions <$> genVersions
    , AnyMessageAndAgency (ServerAgency TokConfirm) . uncurry MsgAcceptVersion <$> genValidVersion'
    , return $ AnyMessageAndAgency (ServerAgency TokConfirm) MsgRefuse
    , return $ AnyMessageAndAgency (ServerAgency TokConfirm) MsgUnknownVersion
    ]
    where
      genValidVersion' :: Gen (VersionNumber, CBOR.Term)
      genValidVersion' = do
        vn <- arbitrary
        Sigma vData (Version _ DictVersion) <- genValidVersion vn
        pure (vn, encodeTerm vData)

prop_codec_VersionNegotiation
  :: AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)
  -> Bool
prop_codec_VersionNegotiation msg =
  runST (prop_codecM codecVersionNegotiation msg)
